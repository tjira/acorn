//! Fourier transform module.

const std = @import("std"); const Complex = std.math.Complex;

const mth = @import("math.zig"  );
const vec = @import("vector.zig");

const StridedArray = @import("stridedarray.zig").StridedArray;
const Vector       = @import("vector.zig"      ).Vector      ;

const asfloat = @import("helper.zig").asfloat;
const bitrev  = @import("helper.zig").bitrev ;

/// Fast Fourier transform for a one-dimensional array. The factor argument is the value in the exponent of the Fourier transform. Factor -1 corresponds to the forward Fourier transform, while factor 1 corresponds to the inverse Fourier transform.
pub fn fft(comptime T: type, arr: StridedArray(Complex(T)), factor: i32) !void {
    const n = arr.len; const logn: u6 = @intCast(std.math.log2(n));

    if (std.math.pow(usize, 2, @intCast(logn)) != n) {
        return error.InvalidFourierTransformLength;
    }

    for (0..n) |i| {

        const j = bitrev(i, logn);

        if (i < j) {
            std.mem.swap(Complex(T), arr.ptr(j), arr.ptr(i));
        }
    }

    for (0..logn) |i| {

        const m = std.math.pow(usize, 2, i + 1); const mix = std.math.complex.exp(Complex(T).init(0, asfloat(T, factor) * 2 * std.math.pi / asfloat(T, m)));

        for (0..n / m) |j| {

            var omega = Complex(T).init(1, 0);

            for (0..m / 2) |k| {

                const t = omega.mul(arr.at(j * m + k + m / 2)); const u = arr.at(j * m + k);

                arr.ptr(j * m + k        ).* = u.add(t);
                arr.ptr(j * m + k + m / 2).* = u.sub(t);

                omega = omega.mul(mix);
            }
        }
    }

    if (factor > 0) for (0..n) |i| {
        arr.ptr(i).* = arr.at(i).div(Complex(T).init(asfloat(T, n), 0));
    };
}

/// Fast Fourier transform for an n-dimensional array. The factor argument is the value in the exponent of the Fourier transform. Factor -1 corresponds to the forward Fourier transform, while factor 1 corresponds to the inverse Fourier transform.
pub fn fftn(comptime T: type, arr: []Complex(T), shape: []const usize, factor: i32) !void {
    const sprod = mth.prod(usize, shape); var stride: usize = 1;

    if (std.math.pow(usize, shape[0], shape.len) != sprod) {
        return error.InvalidFourierTransformShape;
    }

    for (0..shape.len) |i| {

        for (0..sprod / shape[shape.len - i - 1]) |j| {

            var offset: usize = 0; var index: usize = 0;

            for (0..shape.len) |k| if (k != i) {
                offset += (j / std.math.pow(usize, shape[k], shape.len - index - 2) % shape[k]) * std.math.pow(usize, shape[k], k); index += 1;
            };

            try fft(T, StridedArray(Complex(T)){.data = arr, .len = shape[shape.len - i - 1], .stride = stride, .zero = offset}, factor);
        }

        stride *= shape[shape.len - i - 1];
    }
}

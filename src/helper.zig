//! Module with some helper functions.

const std = @import("std");

const A2AU  = @import("constant.zig").A2AU ;
const SM2AN = @import("constant.zig").SM2AN;

const Vector = @import("vector.zig").Vector;

/// Casts an integer to a float.
pub fn asfloat(comptime T: type, a: anytype) T {
    return @as(T, @floatFromInt(a));
}

/// Reverse the bits of a number.
pub fn bitrev(value: anytype, count: u6) @TypeOf(value) {
    var result: @TypeOf(value) = 0; var i: u6 = 0;

    while (i < count) : (i += 1) {
        result |= ((value >> @intCast(i)) & 1) << @intCast(count - 1 - i);
    }

    return result;
}

/// Calls a child process and returns exit term.
pub fn call(argv: []const []const u8, allocator: std.mem.Allocator) !struct {term: std.process.Child.Term, stdout: std.ArrayListUnmanaged(u8), stderr: std.ArrayListUnmanaged(u8)} {
    var child = std.process.Child.init(argv, allocator);

    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;

    const maxsize = 16 * 1024 * 1024;

    var stdout = try std.ArrayListUnmanaged(u8).initCapacity(allocator, maxsize);
    var stderr = try std.ArrayListUnmanaged(u8).initCapacity(allocator, maxsize);

    try child.spawn(); try child.collectOutput(allocator, &stdout, &stderr, maxsize);

    return .{.term = try child.wait(), .stdout = stdout, .stderr = stderr};
}

/// Check if a vector contains a value.
pub fn contains(comptime T: type, v: []const T, value: T) bool {
    for (v) |element| {if (element == value) return true;} return false;
}

/// Check if the passed type is a struct.
pub fn istruct(comptime T: type) bool {
    return @typeInfo(T) == .@"struct";
}

/// Return the maximum of two numbers.
pub fn max(a: anytype, b: @TypeOf(a)) @TypeOf(a) {
    return if (a > b) a else b;
}

/// Return the formatted memory size of a type and count.
pub fn memFormat(comptime T: type, count: usize, allocator: std.mem.Allocator) ![]const u8 {
    const buffer = try allocator.alloc(u8, 9); const bytes = @sizeOf(T) * count;

    const digits = std.math.log10(bytes) + 1;

    const units = switch (digits) {
        1...3 => " B", 4...6 => "kB", 7...9 => "MB", 10...12 => "GB", 13...15 => "TB", else => unreachable
    };

    const size = asfloat(f64, bytes) / switch (digits) {
        1...3 => @as(f64, 1e0), 4...6 => 1e3, 7...9 => 1e6, 10...12 => 1e9, 13...15 => 1e12, else => unreachable
    };

    return try std.fmt.bufPrint(buffer, "{d:6.2} {s}", .{size, units});
}

/// Print a formatted string to stdout.
pub fn print(device: std.fs.File, comptime format: []const u8, args: anytype) !void {
    var buffer: [1024]u8 = undefined; var writer = device.writer(&buffer); const writer_interface = &writer.interface;

    try writer_interface.print(format, args);

    try writer_interface.flush();
}

/// Check if a string contains another string.
fn scontains(haystack: []const u8, needle: []const u8) bool {
    return std.mem.indexOf(u8, haystack, needle) != null;
}

/// Remove the carriage return from a string. Fucking windows.
pub fn uncr(string: []const u8) []const u8 {
    return if (string[string.len - 1] == 13) string[0..string.len - 1] else string;
}

/// Write a string to a file. The file is overwritten if it exists.
pub fn writeToFile(path: []const u8, string: []const u8) !void {
    const file = try std.fs.cwd().createFile(path, .{}); defer file.close();

    var writer = file.writer(); var interface = &writer.interface;

    try interface.print("{s}", .{string}); try interface.flush();
}

pub fn writeVectorAsMolecule(comptime T: type, path: []const u8, r: Vector(T), atoms: Vector(T)) !void {
    const file = try std.fs.cwd().createFile(path, .{}); defer file.close();

    var buffer: [1024]u8 = undefined; var writer = file.writer(&buffer); var interface = &writer.interface;

    try interface.print("{d}\nautomatically generated by acorn\n", .{r.rows / 3});

    for (0..r.rows / 3) |i| {
        for (SM2AN.keys(), SM2AN.values()) |key, value| {
            if (value == @as(u32, @intFromFloat(atoms.at(i)))) {
                try interface.print("{s} {d:20.14} {d:20.14} {d:20.14}\n", .{key, r.at(i * 3) / A2AU, r.at(i * 3 + 1) / A2AU, r.at(i * 3 + 2) / A2AU}); break;
            }
        }
    }

    try interface.flush();
}

/// Extract the i-th geometry from a .xyz file of geometries.
pub fn extractGeometryFromMovie(output_path: []const u8, movie_path: []const u8, i: usize) !void {
    const movie_file  = try std.fs.cwd().openFile(movie_path,    .{}); defer  movie_file.close();
    const output_file = try std.fs.cwd().createFile(output_path, .{}); defer output_file.close();

    var rbuffer: [1024]u8 = undefined;
    var wbuffer: [1024]u8 = undefined;

    var movie_reader  =  movie_file.reader(&rbuffer);
    var output_writer = output_file.writer(&wbuffer);

    var reader_interface =  &movie_reader.interface;
    var writer_interface = &output_writer.interface;

    const natom = try std.fmt.parseInt(u32, try reader_interface.takeDelimiterExclusive('\n'), 10);

    for (0..i * (natom + 2)) |_| {
        _ = try reader_interface.discardDelimiterInclusive('\n');
    }

    try writer_interface.print("{d}\n", .{natom});

    for (0..natom + 1) |_| {
        try writer_interface.print("{s}\n", .{try reader_interface.takeDelimiterExclusive('\n')});
    }

    try writer_interface.flush();
}
